{"ast":null,"code":"import * as XLSX from 'xlsx';\n\n/**\r\n * Validate Excel file before processing\r\n * @param {File} file - File to validate\r\n * @returns {Object} Validation result\r\n */\nexport const validateExcelFile = file => {\n  const errors = [];\n  const warnings = [];\n\n  // Check file type\n  if (!file.name.match(/\\.(xlsx|xls)$/i)) {\n    errors.push('File must be an Excel file (.xlsx or .xls)');\n  }\n\n  // Check file size (10MB limit)\n  if (file.size > 10 * 1024 * 1024) {\n    errors.push('File size must be less than 10MB');\n  }\n\n  // Check if file is empty\n  if (file.size === 0) {\n    errors.push('File is empty');\n  }\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings\n  };\n};\n\n/**\r\n * Comprehensive Excel export function for both device settings and STP data\r\n * @param {Object} deviceSettings - Device configuration parameters\r\n * @param {Array} stpData - Software Test Parameters data\r\n * @param {string} filename - Output filename\r\n * @param {Object} options - Export options\r\n */\nexport const exportComprehensiveData = (deviceSettings, stpData, filename = 'aquatron_data.xlsx', options = {}) => {\n  try {\n    var _deviceSettings$vout_;\n    // Validate inputs\n    if (!deviceSettings && !stpData) {\n      throw new Error('No data provided for export');\n    }\n    const wb = XLSX.utils.book_new();\n\n    // Device Settings sheet\n    if (deviceSettings && Object.keys(deviceSettings).length > 0) {\n      const deviceSettingsData = [{\n        Parameter: 'Freefall',\n        Value: deviceSettings.freefall || 0,\n        Unit: 'ms',\n        Description: 'Freefall time in milliseconds'\n      }, {\n        Parameter: 'HPTF',\n        Value: deviceSettings.hptf || 0,\n        Unit: 'Hz',\n        Description: 'High Power Test Frequency'\n      }, {\n        Parameter: 'Harmonic',\n        Value: deviceSettings.harmonic || 0,\n        Unit: '',\n        Description: 'Harmonic mode (0=FULL, 1=HALF, 2=QUARTER)'\n      }, {\n        Parameter: 'Duration',\n        Value: deviceSettings.duration_ms || 0,\n        Unit: 'ms',\n        Description: 'Test duration in milliseconds'\n      }];\n      const deviceWs = XLSX.utils.json_to_sheet(deviceSettingsData);\n      XLSX.utils.book_append_sheet(wb, deviceWs, 'Device Settings');\n\n      // Vout Table sheet (if available)\n      if (deviceSettings.vout_table && deviceSettings.vout_table.length > 0) {\n        const voutWs = XLSX.utils.json_to_sheet(deviceSettings.vout_table);\n        XLSX.utils.book_append_sheet(wb, voutWs, 'Vout Table');\n      }\n    }\n\n    // STP Data sheet\n    if (stpData && stpData.length > 0) {\n      const stpWs = XLSX.utils.json_to_sheet(stpData);\n      XLSX.utils.book_append_sheet(wb, stpWs, 'Software Test Parameters');\n    }\n\n    // Configuration Info sheet\n    const configInfo = [{\n      Field: 'Export Date',\n      Value: new Date().toISOString(),\n      Description: 'Date and time of export'\n    }, {\n      Field: 'Device Settings Count',\n      Value: deviceSettings ? Object.keys(deviceSettings).filter(k => k !== 'vout_table').length : 0,\n      Description: 'Number of device settings exported'\n    }, {\n      Field: 'Vout Table Entries',\n      Value: (deviceSettings === null || deviceSettings === void 0 ? void 0 : (_deviceSettings$vout_ = deviceSettings.vout_table) === null || _deviceSettings$vout_ === void 0 ? void 0 : _deviceSettings$vout_.length) || 0,\n      Description: 'Number of vout table entries'\n    }, {\n      Field: 'STP Parameters',\n      Value: (stpData === null || stpData === void 0 ? void 0 : stpData.length) || 0,\n      Description: 'Number of software test parameters'\n    }, {\n      Field: 'Format Version',\n      Value: '1.1',\n      Description: 'Excel format version'\n    }, {\n      Field: 'Export Options',\n      Value: JSON.stringify(options),\n      Description: 'Export configuration options'\n    }];\n    const configWs = XLSX.utils.json_to_sheet(configInfo);\n    XLSX.utils.book_append_sheet(wb, configWs, 'Configuration Info');\n    XLSX.writeFile(wb, filename);\n    return {\n      success: true,\n      message: 'Data exported successfully',\n      filename\n    };\n  } catch (error) {\n    console.error('Export error:', error);\n    return {\n      success: false,\n      message: 'Failed to export data',\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Comprehensive Excel import function for both device settings and STP data\r\n * @param {File} file - Excel file to import\r\n * @param {Object} options - Import options\r\n * @returns {Object} Imported data structure\r\n */\nexport const importComprehensiveData = async (file, options = {}) => {\n  return new Promise((resolve, reject) => {\n    // Validate file first\n    const fileValidation = validateExcelFile(file);\n    if (!fileValidation.isValid) {\n      reject({\n        success: false,\n        message: 'File validation failed',\n        errors: fileValidation.errors\n      });\n      return;\n    }\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const data = new Uint8Array(e.target.result);\n        const workbook = XLSX.read(data, {\n          type: 'array'\n        });\n        const result = {\n          deviceSettings: {},\n          stpData: [],\n          voutTable: [],\n          success: true,\n          message: 'Data imported successfully',\n          warnings: [],\n          importedSheets: [],\n          totalRows: 0\n        };\n\n        // Read Device Settings sheet\n        const deviceSheet = workbook.Sheets['Device Settings'];\n        if (deviceSheet) {\n          const deviceData = XLSX.utils.sheet_to_json(deviceSheet);\n          result.totalRows += deviceData.length;\n          deviceData.forEach(row => {\n            if (row.Parameter && row.Value !== undefined) {\n              const value = Number(row.Value);\n              if (!isNaN(value)) {\n                switch (row.Parameter) {\n                  case 'Freefall':\n                    result.deviceSettings.freefall = value;\n                    break;\n                  case 'HPTF':\n                    result.deviceSettings.hptf = value;\n                    break;\n                  case 'Harmonic':\n                    result.deviceSettings.harmonic = value;\n                    break;\n                  case 'Duration':\n                    result.deviceSettings.duration_ms = value;\n                    break;\n                  default:\n                    if (options.allowUnknownParameters) {\n                      result.deviceSettings[row.Parameter] = value;\n                    }\n                    break;\n                }\n              } else {\n                result.warnings.push(`Invalid value for ${row.Parameter}: ${row.Value}`);\n              }\n            }\n          });\n          result.importedSheets.push('Device Settings');\n        }\n\n        // Read Vout Table sheet\n        const voutSheet = workbook.Sheets['Vout Table'];\n        if (voutSheet) {\n          result.voutTable = XLSX.utils.sheet_to_json(voutSheet);\n          result.totalRows += result.voutTable.length;\n          result.importedSheets.push('Vout Table');\n        }\n\n        // Read Software Test Parameters sheet\n        const stpSheet = workbook.Sheets['Software Test Parameters'];\n        if (stpSheet) {\n          let rawStpData = XLSX.utils.sheet_to_json(stpSheet);\n          // Combine duplicates by symbol or name\n          const combined = {};\n          rawStpData.forEach(item => {\n            // Use symbol if present, else name\n            const key = (item.symbol || item.name || '').toString().trim();\n            if (!key) return;\n            if (!combined[key]) {\n              combined[key] = {\n                ...item\n              };\n              if (typeof combined[key].quantity !== 'number') combined[key].quantity = Number(combined[key].quantity) || 0;\n            } else {\n              // Sum quantities\n              const qty = Number(item.quantity) || 0;\n              combined[key].quantity += qty;\n            }\n          });\n          result.stpData = Object.values(combined);\n          result.totalRows += result.stpData.length;\n          result.importedSheets.push('Software Test Parameters');\n        }\n\n        // Validate imported data\n        if (Object.keys(result.deviceSettings).length === 0 && result.voutTable.length === 0 && result.stpData.length === 0) {\n          result.success = false;\n          result.message = 'No valid data found in the Excel file';\n        }\n\n        // Apply validation rules if specified\n        if (options.validateData) {\n          const validationResult = validateImportedData(result);\n          result.validation = validationResult;\n          if (!validationResult.isValid) {\n            result.warnings.push(...validationResult.errors);\n          }\n        }\n        resolve(result);\n      } catch (error) {\n        console.error('Import error:', error);\n        reject({\n          success: false,\n          message: 'Failed to import data',\n          error: error.message\n        });\n      }\n    };\n    reader.onerror = () => {\n      reject({\n        success: false,\n        message: 'Failed to read file'\n      });\n    };\n    reader.readAsArrayBuffer(file);\n  });\n};\n\n/**\r\n * Validate imported data according to business rules\r\n * @param {Object} data - Imported data object\r\n * @returns {Object} Validation result\r\n */\nexport const validateImportedData = data => {\n  const errors = [];\n  const warnings = [];\n\n  // Validate device settings\n  if (data.deviceSettings) {\n    if (data.deviceSettings.freefall !== undefined && (data.deviceSettings.freefall < 0 || data.deviceSettings.freefall > 1000)) {\n      errors.push('Freefall value must be between 0 and 1000 ms');\n    }\n    if (data.deviceSettings.hptf !== undefined && (data.deviceSettings.hptf < 0 || data.deviceSettings.hptf > 10000)) {\n      errors.push('HPTF value must be between 0 and 10000 Hz');\n    }\n    if (data.deviceSettings.harmonic !== undefined && ![0, 1, 2].includes(data.deviceSettings.harmonic)) {\n      errors.push('Harmonic value must be 0, 1, or 2');\n    }\n    if (data.deviceSettings.duration_ms !== undefined && (data.deviceSettings.duration_ms < 1000 || data.deviceSettings.duration_ms > 60000)) {\n      errors.push('Duration must be between 1000 and 60000 ms');\n    }\n  }\n\n  // Validate STP data\n  if (data.stpData && data.stpData.length > 0) {\n    data.stpData.forEach((item, index) => {\n      if (!(item.symbol || item.name)) {\n        errors.push(`Row ${index + 1}: Missing symbol or name`);\n      }\n      // Quantity limit removed\n      if (item.vout_base !== undefined && (item.vout_base < 0 || item.vout_base > 10)) {\n        errors.push(`Row ${index + 1}: Vout base must be between 0 and 10V`);\n      }\n      if (item.freq !== undefined && (item.freq < 1 || item.freq > 10000)) {\n        errors.push(`Row ${index + 1}: Frequency must be between 1 and 10000 Hz`);\n      }\n    });\n  }\n\n  // Validate Vout table\n  if (data.voutTable && data.voutTable.length > 0) {\n    data.voutTable.forEach((item, index) => {\n      if (!item.symbol) {\n        errors.push(`Vout Table Row ${index + 1}: Missing symbol`);\n      }\n      if (item.vout_base !== undefined && (item.vout_base < 0 || item.vout_base > 10)) {\n        errors.push(`Vout Table Row ${index + 1}: Vout base must be between 0 and 10V`);\n      }\n      if (item.freq !== undefined && (item.freq < 1 || item.freq > 10000)) {\n        errors.push(`Vout Table Row ${index + 1}: Frequency must be between 1 and 10000 Hz`);\n      }\n    });\n  }\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n    summary: {\n      totalErrors: errors.length,\n      totalWarnings: warnings.length,\n      deviceSettingsValid: Object.keys(data.deviceSettings || {}).length > 0,\n      stpDataValid: (data.stpData || []).length > 0,\n      voutTableValid: (data.voutTable || []).length > 0\n    }\n  };\n};\n\n/**\r\n * Create a comprehensive template Excel file\r\n * @param {string} filename - Template filename\r\n * @param {Object} options - Template options\r\n */\nexport const createComprehensiveTemplate = (filename = 'aquatron_template.xlsx', options = {}) => {\n  try {\n    const wb = XLSX.utils.book_new();\n    // Only one sheet: Software Test Parameters with columns: symbol (name) and quantity\n    const stpTemplate = [{\n      symbol: 'Li',\n      quantity: 100\n    }, {\n      symbol: 'Ca',\n      quantity: 100\n    }, {\n      symbol: 'Na',\n      quantity: 100\n    }, {\n      symbol: 'Cl',\n      quantity: 100\n    }, {\n      symbol: 'Fe',\n      quantity: 100\n    }, {\n      symbol: 'Zn',\n      quantity: 100\n    }, {\n      symbol: 'Cu',\n      quantity: 100\n    }, {\n      symbol: 'Pb',\n      quantity: 100\n    }, {\n      symbol: 'Mg',\n      quantity: 100\n    }, {\n      symbol: 'Mn',\n      quantity: 100\n    }, {\n      symbol: 'Cd',\n      quantity: 100\n    }, {\n      symbol: 'K',\n      quantity: 100\n    }, {\n      symbol: 'B',\n      quantity: 100\n    }, {\n      symbol: 'F',\n      quantity: 100\n    }, {\n      symbol: 'Mo',\n      quantity: 100\n    }, {\n      symbol: 'Ni',\n      quantity: 100\n    }, {\n      symbol: 'Se',\n      quantity: 100\n    }, {\n      symbol: 'Si',\n      quantity: 100\n    }, {\n      symbol: 'Ag',\n      quantity: 100\n    }, {\n      symbol: 'As',\n      quantity: 100\n    }, {\n      symbol: 'Hg',\n      quantity: 100\n    }, {\n      symbol: 'P',\n      quantity: 100\n    }, {\n      symbol: 'Al',\n      quantity: 100\n    }, {\n      symbol: 'Cr',\n      quantity: 100\n    }, {\n      symbol: 'Co',\n      quantity: 100\n    }, {\n      symbol: 'Ba',\n      quantity: 100\n    }, {\n      symbol: 'Am',\n      quantity: 100\n    }, {\n      symbol: 'NO',\n      quantity: 100\n    }];\n    const stpWs = XLSX.utils.json_to_sheet(stpTemplate);\n    XLSX.utils.book_append_sheet(wb, stpWs, 'Software Test Parameters');\n    XLSX.writeFile(wb, filename);\n    return {\n      success: true,\n      message: 'Template created successfully',\n      filename\n    };\n  } catch (error) {\n    console.error('Template creation error:', error);\n    return {\n      success: false,\n      message: 'Failed to create template',\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Export only STP data for device communication\r\n * @param {Array} stpData - Software Test Parameters data\r\n * @param {string} filename - Output filename\r\n */\nexport const exportSTPForDevice = (stpData, filename = 'stp_for_device.xlsx') => {\n  try {\n    const wb = XLSX.utils.book_new();\n\n    // Create STP data in the exact format needed for device communication\n    const deviceStpData = stpData.map(item => ({\n      symbol: item.symbol,\n      quantity: item.quantity || 100,\n      vout_base: item.vout_base,\n      freq: item.freq\n    }));\n    const stpWs = XLSX.utils.json_to_sheet(deviceStpData);\n    XLSX.utils.book_append_sheet(wb, stpWs, 'STP for Device');\n    XLSX.writeFile(wb, filename);\n    return {\n      success: true,\n      message: 'STP data exported for device communication',\n      filename\n    };\n  } catch (error) {\n    console.error('STP export error:', error);\n    return {\n      success: false,\n      message: 'Failed to export STP data',\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Export only device settings\r\n * @param {Object} deviceSettings - Device configuration parameters\r\n * @param {string} filename - Output filename\r\n */\nexport const exportDeviceSettingsOnly = (deviceSettings, filename = 'device_settings.xlsx') => {\n  try {\n    const wb = XLSX.utils.book_new();\n\n    // Basic device settings sheet\n    const basicSettings = [{\n      Parameter: 'Freefall',\n      Value: deviceSettings.freefall || 0,\n      Unit: 'ms'\n    }, {\n      Parameter: 'HPTF',\n      Value: deviceSettings.hptf || 0,\n      Unit: 'Hz'\n    }, {\n      Parameter: 'Harmonic',\n      Value: deviceSettings.harmonic || 0,\n      Unit: ''\n    }, {\n      Parameter: 'Duration',\n      Value: deviceSettings.duration_ms || 0,\n      Unit: 'ms'\n    }];\n    const basicWs = XLSX.utils.json_to_sheet(basicSettings);\n    XLSX.utils.book_append_sheet(wb, basicWs, 'Basic Settings');\n\n    // Vout table sheet (if available)\n    if (deviceSettings.vout_table && deviceSettings.vout_table.length > 0) {\n      const voutWs = XLSX.utils.json_to_sheet(deviceSettings.vout_table);\n      XLSX.utils.book_append_sheet(wb, voutWs, 'Vout Table');\n    }\n    XLSX.writeFile(wb, filename);\n    return {\n      success: true,\n      message: 'Device settings exported successfully',\n      filename\n    };\n  } catch (error) {\n    console.error('Device settings export error:', error);\n    return {\n      success: false,\n      message: 'Failed to export device settings',\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Import only device settings from Excel file\r\n * @param {File} file - Excel file to import\r\n * @returns {Object} Imported device settings\r\n */\nexport const importDeviceSettingsOnly = async file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const data = new Uint8Array(e.target.result);\n        const workbook = XLSX.read(data, {\n          type: 'array'\n        });\n        const result = {\n          deviceSettings: {},\n          voutTable: [],\n          success: true,\n          message: 'Device settings imported successfully'\n        };\n\n        // Read Basic Settings sheet\n        const basicSheet = workbook.Sheets['Basic Settings'];\n        if (basicSheet) {\n          const basicData = XLSX.utils.sheet_to_json(basicSheet);\n          basicData.forEach(row => {\n            if (row.Parameter && row.Value !== undefined) {\n              const value = Number(row.Value);\n              if (!isNaN(value)) {\n                switch (row.Parameter) {\n                  case 'Freefall':\n                    result.deviceSettings.freefall = value;\n                    break;\n                  case 'HPTF':\n                    result.deviceSettings.hptf = value;\n                    break;\n                  case 'Harmonic':\n                    result.deviceSettings.harmonic = value;\n                    break;\n                  case 'Duration':\n                    result.deviceSettings.duration_ms = value;\n                    break;\n                  default:\n                    break;\n                }\n              }\n            }\n          });\n        }\n\n        // Read Vout Table sheet\n        const voutSheet = workbook.Sheets['Vout Table'];\n        if (voutSheet) {\n          result.voutTable = XLSX.utils.sheet_to_json(voutSheet);\n        }\n        resolve(result);\n      } catch (error) {\n        console.error('Import error:', error);\n        reject({\n          success: false,\n          message: 'Failed to import device settings',\n          error: error.message\n        });\n      }\n    };\n    reader.onerror = () => {\n      reject({\n        success: false,\n        message: 'Failed to read file'\n      });\n    };\n    reader.readAsArrayBuffer(file);\n  });\n};\n\n/**\r\n * Import only STP data from Excel file\r\n * @param {File} file - Excel file to import\r\n * @returns {Object} Imported STP data\r\n */\nexport const importSTPOnly = async file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const data = new Uint8Array(e.target.result);\n        const workbook = XLSX.read(data, {\n          type: 'array'\n        });\n        const result = {\n          stpData: [],\n          success: true,\n          message: 'STP data imported successfully'\n        };\n\n        // Read Software Test Parameters sheet\n        const stpSheet = workbook.Sheets['Software Test Parameters'];\n        if (stpSheet) {\n          result.stpData = XLSX.utils.sheet_to_json(stpSheet);\n        }\n        if (result.stpData.length === 0) {\n          result.success = false;\n          result.message = 'No STP data found in the Excel file';\n        }\n        resolve(result);\n      } catch (error) {\n        console.error('Import error:', error);\n        reject({\n          success: false,\n          message: 'Failed to import STP data',\n          error: error.message\n        });\n      }\n    };\n    reader.onerror = () => {\n      reject({\n        success: false,\n        message: 'Failed to read file'\n      });\n    };\n    reader.readAsArrayBuffer(file);\n  });\n};\n\n/**\r\n * Transform data for different export formats\r\n * @param {Object} data - Data to transform\r\n * @param {string} format - Target format ('csv', 'json', 'xml')\r\n * @returns {Object} Transformed data\r\n */\nexport const transformDataForExport = (data, format = 'excel') => {\n  try {\n    switch (format.toLowerCase()) {\n      case 'csv':\n        return transformToCSV(data);\n      case 'json':\n        return transformToJSON(data);\n      case 'xml':\n        return transformToXML(data);\n      default:\n        return data;\n    }\n  } catch (error) {\n    console.error('Data transformation error:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Transform data to CSV format\r\n * @param {Object} data - Data to transform\r\n * @returns {Object} CSV data\r\n */\nconst transformToCSV = data => {\n  const csvData = {};\n  if (data.deviceSettings) {\n    const deviceCSV = Object.entries(data.deviceSettings).filter(([key]) => key !== 'vout_table').map(([key, value]) => `${key},${value}`).join('\\n');\n    csvData.deviceSettings = `Parameter,Value\\n${csvData.deviceSettings}`;\n  }\n  if (data.stpData) {\n    const stpCSV = data.stpData.map(row => Object.values(row).join(',')).join('\\n');\n    csvData.stpData = `${Object.keys(data.stpData[0] || {}).join(',')}\\n${stpCSV}`;\n  }\n  return {\n    success: true,\n    data: csvData,\n    format: 'csv'\n  };\n};\n\n/**\r\n * Transform data to JSON format\r\n * @param {Object} data - Data to transform\r\n * @returns {Object} JSON data\r\n */\nconst transformToJSON = data => {\n  return {\n    success: true,\n    data: JSON.stringify(data, null, 2),\n    format: 'json'\n  };\n};\n\n/**\r\n * Transform data to XML format\r\n * @param {Object} data - Data to transform\r\n * @returns {Object} XML data\r\n */\nconst transformToXML = data => {\n  let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<AquatronData>\\n';\n  if (data.deviceSettings) {\n    xml += '  <DeviceSettings>\\n';\n    Object.entries(data.deviceSettings).filter(([key]) => key !== 'vout_table').forEach(([key, value]) => {\n      xml += `    <${key}>${value}</${key}>\\n`;\n    });\n    xml += '  </DeviceSettings>\\n';\n  }\n  if (data.stpData) {\n    xml += '  <STPData>\\n';\n    data.stpData.forEach(item => {\n      xml += '    <Element>\\n';\n      Object.entries(item).forEach(([key, value]) => {\n        xml += `      <${key}>${value}</${key}>\\n`;\n      });\n      xml += '    </Element>\\n';\n    });\n    xml += '  </STPData>\\n';\n  }\n  xml += '</AquatronData>';\n  return {\n    success: true,\n    data: xml,\n    format: 'xml'\n  };\n};\n\n/**\r\n * Create a backup of current data\r\n * @param {Object} data - Data to backup\r\n * @param {string} filename - Backup filename\r\n * @returns {Object} Backup result\r\n */\nexport const createDataBackup = (data, filename = `aquatron_backup_${new Date().toISOString().split('T')[0]}.xlsx`) => {\n  try {\n    const backupData = {\n      deviceSettings: data.deviceSettings || {},\n      stpData: data.stpData || [],\n      voutTable: data.voutTable || [],\n      backupInfo: {\n        timestamp: new Date().toISOString(),\n        version: '1.0',\n        description: 'Automatic backup of Aquatron data'\n      }\n    };\n    const result = exportComprehensiveData(backupData.deviceSettings, backupData.stpData, filename, {\n      isBackup: true,\n      timestamp: backupData.backupInfo.timestamp\n    });\n    return result;\n  } catch (error) {\n    console.error('Backup creation error:', error);\n    return {\n      success: false,\n      message: 'Failed to create backup',\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Restore data from backup\r\n * @param {File} backupFile - Backup file to restore from\r\n * @returns {Object} Restore result\r\n */\nexport const restoreFromBackup = async backupFile => {\n  try {\n    const result = await importComprehensiveData(backupFile, {\n      validateData: true,\n      allowUnknownParameters: true,\n      isRestore: true\n    });\n    if (result.success) {\n      // Validate backup integrity\n      if (!result.backupInfo) {\n        result.warnings.push('Backup file may not be a valid backup (missing backup info)');\n      }\n      return result;\n    } else {\n      return result;\n    }\n  } catch (error) {\n    console.error('Restore error:', error);\n    return {\n      success: false,\n      message: 'Failed to restore from backup',\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Compare two datasets and highlight differences\r\n * @param {Object} originalData - Original data\r\n * @param {Object} newData - New data to compare\r\n * @returns {Object} Comparison result\r\n */\nexport const compareDataSets = (originalData, newData) => {\n  const differences = {\n    deviceSettings: {},\n    stpData: [],\n    voutTable: [],\n    summary: {\n      totalChanges: 0,\n      deviceSettingsChanges: 0,\n      stpDataChanges: 0,\n      voutTableChanges: 0\n    }\n  };\n  try {\n    // Compare device settings\n    if (originalData.deviceSettings && newData.deviceSettings) {\n      Object.keys(originalData.deviceSettings).forEach(key => {\n        if (key !== 'vout_table' && originalData.deviceSettings[key] !== newData.deviceSettings[key]) {\n          differences.deviceSettings[key] = {\n            original: originalData.deviceSettings[key],\n            new: newData.deviceSettings[key]\n          };\n          differences.summary.deviceSettingsChanges++;\n          differences.summary.totalChanges++;\n        }\n      });\n    }\n\n    // Compare STP data\n    if (originalData.stpData && newData.stpData) {\n      const originalMap = new Map(originalData.stpData.map(item => [item.symbol, item]));\n      const newMap = new Map(newData.stpData.map(item => [item.symbol, item]));\n\n      // Find added, removed, and modified items\n      newData.stpData.forEach(newItem => {\n        const originalItem = originalMap.get(newItem.symbol);\n        if (!originalItem) {\n          differences.stpData.push({\n            type: 'added',\n            item: newItem\n          });\n          differences.summary.stpDataChanges++;\n          differences.summary.totalChanges++;\n        } else if (JSON.stringify(originalItem) !== JSON.stringify(newItem)) {\n          differences.stpData.push({\n            type: 'modified',\n            symbol: newItem.symbol,\n            original: originalItem,\n            new: newItem\n          });\n          differences.summary.stpDataChanges++;\n          differences.summary.totalChanges++;\n        }\n      });\n      originalData.stpData.forEach(originalItem => {\n        if (!newMap.has(originalItem.symbol)) {\n          differences.stpData.push({\n            type: 'removed',\n            item: originalItem\n          });\n          differences.summary.stpDataChanges++;\n          differences.summary.totalChanges++;\n        }\n      });\n    }\n    return {\n      success: true,\n      differences\n    };\n  } catch (error) {\n    console.error('Data comparison error:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Export data summary report\r\n * @param {Object} data - Data to summarize\r\n * @param {string} filename - Output filename\r\n * @returns {Object} Export result\r\n */\nexport const exportDataSummary = (data, filename = 'aquatron_summary.xlsx') => {\n  try {\n    const wb = XLSX.utils.book_new();\n\n    // Summary sheet\n    const summaryData = [{\n      Metric: 'Total Device Settings',\n      Value: Object.keys(data.deviceSettings || {}).filter(k => k !== 'vout_table').length\n    }, {\n      Metric: 'Total STP Parameters',\n      Value: (data.stpData || []).length\n    }, {\n      Metric: 'Total Vout Table Entries',\n      Value: (data.voutTable || []).length\n    }, {\n      Metric: 'Export Date',\n      Value: new Date().toISOString()\n    }, {\n      Metric: 'Data Version',\n      Value: '1.0'\n    }];\n    const summaryWs = XLSX.utils.json_to_sheet(summaryData);\n    XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');\n\n    // Statistics sheet\n    if (data.stpData && data.stpData.length > 0) {\n      const statsData = [{\n        Statistic: 'Average Quantity',\n        Value: data.stpData.reduce((sum, item) => sum + (item.quantity || 0), 0) / data.stpData.length\n      }, {\n        Statistic: 'Average Vout Base',\n        Value: data.stpData.reduce((sum, item) => sum + (item.vout_base || 0), 0) / data.stpData.length\n      }, {\n        Statistic: 'Average Frequency',\n        Value: data.stpData.reduce((sum, item) => sum + (item.freq || 0), 0) / data.stpData.length\n      }, {\n        Statistic: 'Min Quantity',\n        Value: Math.min(...data.stpData.map(item => item.quantity || 0))\n      }, {\n        Statistic: 'Max Quantity',\n        Value: Math.max(...data.stpData.map(item => item.quantity || 0))\n      }];\n      const statsWs = XLSX.utils.json_to_sheet(statsData);\n      XLSX.utils.book_append_sheet(wb, statsWs, 'Statistics');\n    }\n    XLSX.writeFile(wb, filename);\n    return {\n      success: true,\n      message: 'Data summary exported successfully',\n      filename\n    };\n  } catch (error) {\n    console.error('Summary export error:', error);\n    return {\n      success: false,\n      message: 'Failed to export data summary',\n      error: error.message\n    };\n  }\n};","map":{"version":3,"names":["XLSX","validateExcelFile","file","errors","warnings","name","match","push","size","isValid","length","exportComprehensiveData","deviceSettings","stpData","filename","options","_deviceSettings$vout_","Error","wb","utils","book_new","Object","keys","deviceSettingsData","Parameter","Value","freefall","Unit","Description","hptf","harmonic","duration_ms","deviceWs","json_to_sheet","book_append_sheet","vout_table","voutWs","stpWs","configInfo","Field","Date","toISOString","filter","k","JSON","stringify","configWs","writeFile","success","message","error","console","importComprehensiveData","Promise","resolve","reject","fileValidation","reader","FileReader","onload","e","data","Uint8Array","target","result","workbook","read","type","voutTable","importedSheets","totalRows","deviceSheet","Sheets","deviceData","sheet_to_json","forEach","row","undefined","value","Number","isNaN","allowUnknownParameters","voutSheet","stpSheet","rawStpData","combined","item","key","symbol","toString","trim","quantity","qty","values","validateData","validationResult","validateImportedData","validation","onerror","readAsArrayBuffer","includes","index","vout_base","freq","summary","totalErrors","totalWarnings","deviceSettingsValid","stpDataValid","voutTableValid","createComprehensiveTemplate","stpTemplate","exportSTPForDevice","deviceStpData","map","exportDeviceSettingsOnly","basicSettings","basicWs","importDeviceSettingsOnly","basicSheet","basicData","importSTPOnly","transformDataForExport","format","toLowerCase","transformToCSV","transformToJSON","transformToXML","csvData","deviceCSV","entries","join","stpCSV","xml","createDataBackup","split","backupData","backupInfo","timestamp","version","description","isBackup","restoreFromBackup","backupFile","isRestore","compareDataSets","originalData","newData","differences","totalChanges","deviceSettingsChanges","stpDataChanges","voutTableChanges","original","new","originalMap","Map","newMap","newItem","originalItem","get","has","exportDataSummary","summaryData","Metric","summaryWs","statsData","Statistic","reduce","sum","Math","min","max","statsWs"],"sources":["D:/projects/aquatron/aquatronics/aquatron-frontend/src/utils/excelUtils.js"],"sourcesContent":["import * as XLSX from 'xlsx';\r\n\r\n/**\r\n * Validate Excel file before processing\r\n * @param {File} file - File to validate\r\n * @returns {Object} Validation result\r\n */\r\nexport const validateExcelFile = (file) => {\r\n  const errors = [];\r\n  const warnings = [];\r\n\r\n  // Check file type\r\n  if (!file.name.match(/\\.(xlsx|xls)$/i)) {\r\n    errors.push('File must be an Excel file (.xlsx or .xls)');\r\n  }\r\n\r\n  // Check file size (10MB limit)\r\n  if (file.size > 10 * 1024 * 1024) {\r\n    errors.push('File size must be less than 10MB');\r\n  }\r\n\r\n  // Check if file is empty\r\n  if (file.size === 0) {\r\n    errors.push('File is empty');\r\n  }\r\n\r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n    warnings\r\n  };\r\n};\r\n\r\n/**\r\n * Comprehensive Excel export function for both device settings and STP data\r\n * @param {Object} deviceSettings - Device configuration parameters\r\n * @param {Array} stpData - Software Test Parameters data\r\n * @param {string} filename - Output filename\r\n * @param {Object} options - Export options\r\n */\r\nexport const exportComprehensiveData = (deviceSettings, stpData, filename = 'aquatron_data.xlsx', options = {}) => {\r\n  try {\r\n    // Validate inputs\r\n    if (!deviceSettings && !stpData) {\r\n      throw new Error('No data provided for export');\r\n    }\r\n\r\n    const wb = XLSX.utils.book_new();\r\n    \r\n    // Device Settings sheet\r\n    if (deviceSettings && Object.keys(deviceSettings).length > 0) {\r\n      const deviceSettingsData = [\r\n        { Parameter: 'Freefall', Value: deviceSettings.freefall || 0, Unit: 'ms', Description: 'Freefall time in milliseconds' },\r\n        { Parameter: 'HPTF', Value: deviceSettings.hptf || 0, Unit: 'Hz', Description: 'High Power Test Frequency' },\r\n        { Parameter: 'Harmonic', Value: deviceSettings.harmonic || 0, Unit: '', Description: 'Harmonic mode (0=FULL, 1=HALF, 2=QUARTER)' },\r\n        { Parameter: 'Duration', Value: deviceSettings.duration_ms || 0, Unit: 'ms', Description: 'Test duration in milliseconds' }\r\n      ];\r\n      const deviceWs = XLSX.utils.json_to_sheet(deviceSettingsData);\r\n      XLSX.utils.book_append_sheet(wb, deviceWs, 'Device Settings');\r\n      \r\n      // Vout Table sheet (if available)\r\n      if (deviceSettings.vout_table && deviceSettings.vout_table.length > 0) {\r\n        const voutWs = XLSX.utils.json_to_sheet(deviceSettings.vout_table);\r\n        XLSX.utils.book_append_sheet(wb, voutWs, 'Vout Table');\r\n      }\r\n    }\r\n    \r\n    // STP Data sheet\r\n    if (stpData && stpData.length > 0) {\r\n      const stpWs = XLSX.utils.json_to_sheet(stpData);\r\n      XLSX.utils.book_append_sheet(wb, stpWs, 'Software Test Parameters');\r\n    }\r\n    \r\n    // Configuration Info sheet\r\n    const configInfo = [\r\n      { Field: 'Export Date', Value: new Date().toISOString(), Description: 'Date and time of export' },\r\n      { Field: 'Device Settings Count', Value: deviceSettings ? Object.keys(deviceSettings).filter(k => k !== 'vout_table').length : 0, Description: 'Number of device settings exported' },\r\n      { Field: 'Vout Table Entries', Value: deviceSettings?.vout_table?.length || 0, Description: 'Number of vout table entries' },\r\n      { Field: 'STP Parameters', Value: stpData?.length || 0, Description: 'Number of software test parameters' },\r\n      { Field: 'Format Version', Value: '1.1', Description: 'Excel format version' },\r\n      { Field: 'Export Options', Value: JSON.stringify(options), Description: 'Export configuration options' }\r\n    ];\r\n    const configWs = XLSX.utils.json_to_sheet(configInfo);\r\n    XLSX.utils.book_append_sheet(wb, configWs, 'Configuration Info');\r\n    \r\n    XLSX.writeFile(wb, filename);\r\n    return { success: true, message: 'Data exported successfully', filename };\r\n  } catch (error) {\r\n    console.error('Export error:', error);\r\n    return { success: false, message: 'Failed to export data', error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Comprehensive Excel import function for both device settings and STP data\r\n * @param {File} file - Excel file to import\r\n * @param {Object} options - Import options\r\n * @returns {Object} Imported data structure\r\n */\r\nexport const importComprehensiveData = async (file, options = {}) => {\r\n  return new Promise((resolve, reject) => {\r\n    // Validate file first\r\n    const fileValidation = validateExcelFile(file);\r\n    if (!fileValidation.isValid) {\r\n      reject({ \r\n        success: false, \r\n        message: 'File validation failed', \r\n        errors: fileValidation.errors \r\n      });\r\n      return;\r\n    }\r\n\r\n    const reader = new FileReader();\r\n    \r\n    reader.onload = (e) => {\r\n      try {\r\n        const data = new Uint8Array(e.target.result);\r\n        const workbook = XLSX.read(data, { type: 'array' });\r\n        \r\n        const result = {\r\n          deviceSettings: {},\r\n          stpData: [],\r\n          voutTable: [],\r\n          success: true,\r\n          message: 'Data imported successfully',\r\n          warnings: [],\r\n          importedSheets: [],\r\n          totalRows: 0\r\n        };\r\n        \r\n        // Read Device Settings sheet\r\n        const deviceSheet = workbook.Sheets['Device Settings'];\r\n        if (deviceSheet) {\r\n          const deviceData = XLSX.utils.sheet_to_json(deviceSheet);\r\n          result.totalRows += deviceData.length;\r\n          deviceData.forEach(row => {\r\n            if (row.Parameter && row.Value !== undefined) {\r\n              const value = Number(row.Value);\r\n              if (!isNaN(value)) {\r\n                switch (row.Parameter) {\r\n                  case 'Freefall':\r\n                    result.deviceSettings.freefall = value;\r\n                    break;\r\n                  case 'HPTF':\r\n                    result.deviceSettings.hptf = value;\r\n                    break;\r\n                  case 'Harmonic':\r\n                    result.deviceSettings.harmonic = value;\r\n                    break;\r\n                  case 'Duration':\r\n                    result.deviceSettings.duration_ms = value;\r\n                    break;\r\n                  default:\r\n                    if (options.allowUnknownParameters) {\r\n                      result.deviceSettings[row.Parameter] = value;\r\n                    }\r\n                    break;\r\n                }\r\n              } else {\r\n                result.warnings.push(`Invalid value for ${row.Parameter}: ${row.Value}`);\r\n              }\r\n            }\r\n          });\r\n          result.importedSheets.push('Device Settings');\r\n        }\r\n        \r\n        // Read Vout Table sheet\r\n        const voutSheet = workbook.Sheets['Vout Table'];\r\n        if (voutSheet) {\r\n          result.voutTable = XLSX.utils.sheet_to_json(voutSheet);\r\n          result.totalRows += result.voutTable.length;\r\n          result.importedSheets.push('Vout Table');\r\n        }\r\n        \r\n        // Read Software Test Parameters sheet\r\n        const stpSheet = workbook.Sheets['Software Test Parameters'];\r\n        if (stpSheet) {\r\n          let rawStpData = XLSX.utils.sheet_to_json(stpSheet);\r\n          // Combine duplicates by symbol or name\r\n          const combined = {};\r\n          rawStpData.forEach(item => {\r\n            // Use symbol if present, else name\r\n            const key = (item.symbol || item.name || '').toString().trim();\r\n            if (!key) return;\r\n            if (!combined[key]) {\r\n              combined[key] = { ...item };\r\n              if (typeof combined[key].quantity !== 'number') combined[key].quantity = Number(combined[key].quantity) || 0;\r\n            } else {\r\n              // Sum quantities\r\n              const qty = Number(item.quantity) || 0;\r\n              combined[key].quantity += qty;\r\n            }\r\n          });\r\n          result.stpData = Object.values(combined);\r\n          result.totalRows += result.stpData.length;\r\n          result.importedSheets.push('Software Test Parameters');\r\n        }\r\n        \r\n        // Validate imported data\r\n        if (Object.keys(result.deviceSettings).length === 0 && \r\n            result.voutTable.length === 0 && \r\n            result.stpData.length === 0) {\r\n          result.success = false;\r\n          result.message = 'No valid data found in the Excel file';\r\n        }\r\n        \r\n        // Apply validation rules if specified\r\n        if (options.validateData) {\r\n          const validationResult = validateImportedData(result);\r\n          result.validation = validationResult;\r\n          if (!validationResult.isValid) {\r\n            result.warnings.push(...validationResult.errors);\r\n          }\r\n        }\r\n        \r\n        resolve(result);\r\n      } catch (error) {\r\n        console.error('Import error:', error);\r\n        reject({ \r\n          success: false, \r\n          message: 'Failed to import data', \r\n          error: error.message \r\n        });\r\n      }\r\n    };\r\n    \r\n    reader.onerror = () => {\r\n      reject({ \r\n        success: false, \r\n        message: 'Failed to read file' \r\n      });\r\n    };\r\n    \r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n};\r\n\r\n/**\r\n * Validate imported data according to business rules\r\n * @param {Object} data - Imported data object\r\n * @returns {Object} Validation result\r\n */\r\nexport const validateImportedData = (data) => {\r\n  const errors = [];\r\n  const warnings = [];\r\n  \r\n  // Validate device settings\r\n  if (data.deviceSettings) {\r\n    if (data.deviceSettings.freefall !== undefined && (data.deviceSettings.freefall < 0 || data.deviceSettings.freefall > 1000)) {\r\n      errors.push('Freefall value must be between 0 and 1000 ms');\r\n    }\r\n    if (data.deviceSettings.hptf !== undefined && (data.deviceSettings.hptf < 0 || data.deviceSettings.hptf > 10000)) {\r\n      errors.push('HPTF value must be between 0 and 10000 Hz');\r\n    }\r\n    if (data.deviceSettings.harmonic !== undefined && ![0, 1, 2].includes(data.deviceSettings.harmonic)) {\r\n      errors.push('Harmonic value must be 0, 1, or 2');\r\n    }\r\n    if (data.deviceSettings.duration_ms !== undefined && (data.deviceSettings.duration_ms < 1000 || data.deviceSettings.duration_ms > 60000)) {\r\n      errors.push('Duration must be between 1000 and 60000 ms');\r\n    }\r\n  }\r\n  \r\n  // Validate STP data\r\n  if (data.stpData && data.stpData.length > 0) {\r\n    data.stpData.forEach((item, index) => {\r\n      if (!(item.symbol || item.name)) {\r\n        errors.push(`Row ${index + 1}: Missing symbol or name`);\r\n      }\r\n      // Quantity limit removed\r\n      if (item.vout_base !== undefined && (item.vout_base < 0 || item.vout_base > 10)) {\r\n        errors.push(`Row ${index + 1}: Vout base must be between 0 and 10V`);\r\n      }\r\n      if (item.freq !== undefined && (item.freq < 1 || item.freq > 10000)) {\r\n        errors.push(`Row ${index + 1}: Frequency must be between 1 and 10000 Hz`);\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Validate Vout table\r\n  if (data.voutTable && data.voutTable.length > 0) {\r\n    data.voutTable.forEach((item, index) => {\r\n      if (!item.symbol) {\r\n        errors.push(`Vout Table Row ${index + 1}: Missing symbol`);\r\n      }\r\n      if (item.vout_base !== undefined && (item.vout_base < 0 || item.vout_base > 10)) {\r\n        errors.push(`Vout Table Row ${index + 1}: Vout base must be between 0 and 10V`);\r\n      }\r\n      if (item.freq !== undefined && (item.freq < 1 || item.freq > 10000)) {\r\n        errors.push(`Vout Table Row ${index + 1}: Frequency must be between 1 and 10000 Hz`);\r\n      }\r\n    });\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n    warnings,\r\n    summary: {\r\n      totalErrors: errors.length,\r\n      totalWarnings: warnings.length,\r\n      deviceSettingsValid: Object.keys(data.deviceSettings || {}).length > 0,\r\n      stpDataValid: (data.stpData || []).length > 0,\r\n      voutTableValid: (data.voutTable || []).length > 0\r\n    }\r\n  };\r\n};\r\n\r\n/**\r\n * Create a comprehensive template Excel file\r\n * @param {string} filename - Template filename\r\n * @param {Object} options - Template options\r\n */\r\nexport const createComprehensiveTemplate = (filename = 'aquatron_template.xlsx', options = {}) => {\r\n  try {\r\n    const wb = XLSX.utils.book_new();\r\n    // Only one sheet: Software Test Parameters with columns: symbol (name) and quantity\r\n    const stpTemplate = [\r\n      { symbol: 'Li', quantity: 100 },\r\n      { symbol: 'Ca', quantity: 100 },\r\n      { symbol: 'Na', quantity: 100 },\r\n      { symbol: 'Cl', quantity: 100 },\r\n      { symbol: 'Fe', quantity: 100 },\r\n      { symbol: 'Zn', quantity: 100 },\r\n      { symbol: 'Cu', quantity: 100 },\r\n      { symbol: 'Pb', quantity: 100 },\r\n      { symbol: 'Mg', quantity: 100 },\r\n      { symbol: 'Mn', quantity: 100 },\r\n      { symbol: 'Cd', quantity: 100 },\r\n      { symbol: 'K', quantity: 100 },\r\n      { symbol: 'B', quantity: 100 },\r\n      { symbol: 'F', quantity: 100 },\r\n      { symbol: 'Mo', quantity: 100 },\r\n      { symbol: 'Ni', quantity: 100 },\r\n      { symbol: 'Se', quantity: 100 },\r\n      { symbol: 'Si', quantity: 100 },\r\n      { symbol: 'Ag', quantity: 100 },\r\n      { symbol: 'As', quantity: 100 },\r\n      { symbol: 'Hg', quantity: 100 },\r\n      { symbol: 'P', quantity: 100 },\r\n      { symbol: 'Al', quantity: 100 },\r\n      { symbol: 'Cr', quantity: 100 },\r\n      { symbol: 'Co', quantity: 100 },\r\n      { symbol: 'Ba', quantity: 100 },\r\n      { symbol: 'Am', quantity: 100 },\r\n      { symbol: 'NO', quantity: 100 }\r\n    ];\r\n    const stpWs = XLSX.utils.json_to_sheet(stpTemplate);\r\n    XLSX.utils.book_append_sheet(wb, stpWs, 'Software Test Parameters');\r\n    XLSX.writeFile(wb, filename);\r\n    return { success: true, message: 'Template created successfully', filename };\r\n  } catch (error) {\r\n    console.error('Template creation error:', error);\r\n    return { success: false, message: 'Failed to create template', error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Export only STP data for device communication\r\n * @param {Array} stpData - Software Test Parameters data\r\n * @param {string} filename - Output filename\r\n */\r\nexport const exportSTPForDevice = (stpData, filename = 'stp_for_device.xlsx') => {\r\n  try {\r\n    const wb = XLSX.utils.book_new();\r\n    \r\n    // Create STP data in the exact format needed for device communication\r\n    const deviceStpData = stpData.map(item => ({\r\n      symbol: item.symbol,\r\n      quantity: item.quantity || 100,\r\n      vout_base: item.vout_base,\r\n      freq: item.freq\r\n    }));\r\n    \r\n    const stpWs = XLSX.utils.json_to_sheet(deviceStpData);\r\n    XLSX.utils.book_append_sheet(wb, stpWs, 'STP for Device');\r\n    \r\n    XLSX.writeFile(wb, filename);\r\n    return { success: true, message: 'STP data exported for device communication', filename };\r\n  } catch (error) {\r\n    console.error('STP export error:', error);\r\n    return { success: false, message: 'Failed to export STP data', error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Export only device settings\r\n * @param {Object} deviceSettings - Device configuration parameters\r\n * @param {string} filename - Output filename\r\n */\r\nexport const exportDeviceSettingsOnly = (deviceSettings, filename = 'device_settings.xlsx') => {\r\n  try {\r\n    const wb = XLSX.utils.book_new();\r\n    \r\n    // Basic device settings sheet\r\n    const basicSettings = [\r\n      { Parameter: 'Freefall', Value: deviceSettings.freefall || 0, Unit: 'ms' },\r\n      { Parameter: 'HPTF', Value: deviceSettings.hptf || 0, Unit: 'Hz' },\r\n      { Parameter: 'Harmonic', Value: deviceSettings.harmonic || 0, Unit: '' },\r\n      { Parameter: 'Duration', Value: deviceSettings.duration_ms || 0, Unit: 'ms' }\r\n    ];\r\n    const basicWs = XLSX.utils.json_to_sheet(basicSettings);\r\n    XLSX.utils.book_append_sheet(wb, basicWs, 'Basic Settings');\r\n    \r\n    // Vout table sheet (if available)\r\n    if (deviceSettings.vout_table && deviceSettings.vout_table.length > 0) {\r\n      const voutWs = XLSX.utils.json_to_sheet(deviceSettings.vout_table);\r\n      XLSX.utils.book_append_sheet(wb, voutWs, 'Vout Table');\r\n    }\r\n    \r\n    XLSX.writeFile(wb, filename);\r\n    return { success: true, message: 'Device settings exported successfully', filename };\r\n  } catch (error) {\r\n    console.error('Device settings export error:', error);\r\n    return { success: false, message: 'Failed to export device settings', error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Import only device settings from Excel file\r\n * @param {File} file - Excel file to import\r\n * @returns {Object} Imported device settings\r\n */\r\nexport const importDeviceSettingsOnly = async (file) => {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    \r\n    reader.onload = (e) => {\r\n      try {\r\n        const data = new Uint8Array(e.target.result);\r\n        const workbook = XLSX.read(data, { type: 'array' });\r\n        \r\n        const result = {\r\n          deviceSettings: {},\r\n          voutTable: [],\r\n          success: true,\r\n          message: 'Device settings imported successfully'\r\n        };\r\n        \r\n        // Read Basic Settings sheet\r\n        const basicSheet = workbook.Sheets['Basic Settings'];\r\n        if (basicSheet) {\r\n          const basicData = XLSX.utils.sheet_to_json(basicSheet);\r\n          basicData.forEach(row => {\r\n            if (row.Parameter && row.Value !== undefined) {\r\n              const value = Number(row.Value);\r\n              if (!isNaN(value)) {\r\n                switch (row.Parameter) {\r\n                  case 'Freefall':\r\n                    result.deviceSettings.freefall = value;\r\n                    break;\r\n                  case 'HPTF':\r\n                    result.deviceSettings.hptf = value;\r\n                    break;\r\n                  case 'Harmonic':\r\n                    result.deviceSettings.harmonic = value;\r\n                    break;\r\n                  case 'Duration':\r\n                    result.deviceSettings.duration_ms = value;\r\n                    break;\r\n                  default:\r\n                    break;\r\n                }\r\n              }\r\n            }\r\n          });\r\n        }\r\n        \r\n        // Read Vout Table sheet\r\n        const voutSheet = workbook.Sheets['Vout Table'];\r\n        if (voutSheet) {\r\n          result.voutTable = XLSX.utils.sheet_to_json(voutSheet);\r\n        }\r\n        \r\n        resolve(result);\r\n      } catch (error) {\r\n        console.error('Import error:', error);\r\n        reject({ \r\n          success: false, \r\n          message: 'Failed to import device settings', \r\n          error: error.message \r\n        });\r\n      }\r\n    };\r\n    \r\n    reader.onerror = () => {\r\n      reject({ \r\n        success: false, \r\n        message: 'Failed to read file' \r\n      });\r\n    };\r\n    \r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n};\r\n\r\n/**\r\n * Import only STP data from Excel file\r\n * @param {File} file - Excel file to import\r\n * @returns {Object} Imported STP data\r\n */\r\nexport const importSTPOnly = async (file) => {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    \r\n    reader.onload = (e) => {\r\n      try {\r\n        const data = new Uint8Array(e.target.result);\r\n        const workbook = XLSX.read(data, { type: 'array' });\r\n        \r\n        const result = {\r\n          stpData: [],\r\n          success: true,\r\n          message: 'STP data imported successfully'\r\n        };\r\n        \r\n        // Read Software Test Parameters sheet\r\n        const stpSheet = workbook.Sheets['Software Test Parameters'];\r\n        if (stpSheet) {\r\n          result.stpData = XLSX.utils.sheet_to_json(stpSheet);\r\n        }\r\n        \r\n        if (result.stpData.length === 0) {\r\n          result.success = false;\r\n          result.message = 'No STP data found in the Excel file';\r\n        }\r\n        \r\n        resolve(result);\r\n      } catch (error) {\r\n        console.error('Import error:', error);\r\n        reject({ \r\n          success: false, \r\n          message: 'Failed to import STP data', \r\n          error: error.message \r\n        });\r\n      }\r\n    };\r\n    \r\n    reader.onerror = () => {\r\n      reject({ \r\n        success: false, \r\n        message: 'Failed to read file' \r\n      });\r\n    };\r\n    \r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n};\r\n\r\n/**\r\n * Transform data for different export formats\r\n * @param {Object} data - Data to transform\r\n * @param {string} format - Target format ('csv', 'json', 'xml')\r\n * @returns {Object} Transformed data\r\n */\r\nexport const transformDataForExport = (data, format = 'excel') => {\r\n  try {\r\n    switch (format.toLowerCase()) {\r\n      case 'csv':\r\n        return transformToCSV(data);\r\n      case 'json':\r\n        return transformToJSON(data);\r\n      case 'xml':\r\n        return transformToXML(data);\r\n      default:\r\n        return data;\r\n    }\r\n  } catch (error) {\r\n    console.error('Data transformation error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Transform data to CSV format\r\n * @param {Object} data - Data to transform\r\n * @returns {Object} CSV data\r\n */\r\nconst transformToCSV = (data) => {\r\n  const csvData = {};\r\n  \r\n  if (data.deviceSettings) {\r\n    const deviceCSV = Object.entries(data.deviceSettings)\r\n      .filter(([key]) => key !== 'vout_table')\r\n      .map(([key, value]) => `${key},${value}`)\r\n      .join('\\n');\r\n    csvData.deviceSettings = `Parameter,Value\\n${csvData.deviceSettings}`;\r\n  }\r\n  \r\n  if (data.stpData) {\r\n    const stpCSV = data.stpData.map(row => \r\n      Object.values(row).join(',')\r\n    ).join('\\n');\r\n    csvData.stpData = `${Object.keys(data.stpData[0] || {}).join(',')}\\n${stpCSV}`;\r\n  }\r\n  \r\n  return { success: true, data: csvData, format: 'csv' };\r\n};\r\n\r\n/**\r\n * Transform data to JSON format\r\n * @param {Object} data - Data to transform\r\n * @returns {Object} JSON data\r\n */\r\nconst transformToJSON = (data) => {\r\n  return { \r\n    success: true, \r\n    data: JSON.stringify(data, null, 2), \r\n    format: 'json' \r\n  };\r\n};\r\n\r\n/**\r\n * Transform data to XML format\r\n * @param {Object} data - Data to transform\r\n * @returns {Object} XML data\r\n */\r\nconst transformToXML = (data) => {\r\n  let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<AquatronData>\\n';\r\n  \r\n  if (data.deviceSettings) {\r\n    xml += '  <DeviceSettings>\\n';\r\n    Object.entries(data.deviceSettings)\r\n      .filter(([key]) => key !== 'vout_table')\r\n      .forEach(([key, value]) => {\r\n        xml += `    <${key}>${value}</${key}>\\n`;\r\n      });\r\n    xml += '  </DeviceSettings>\\n';\r\n  }\r\n  \r\n  if (data.stpData) {\r\n    xml += '  <STPData>\\n';\r\n    data.stpData.forEach(item => {\r\n      xml += '    <Element>\\n';\r\n      Object.entries(item).forEach(([key, value]) => {\r\n        xml += `      <${key}>${value}</${key}>\\n`;\r\n      });\r\n      xml += '    </Element>\\n';\r\n    });\r\n    xml += '  </STPData>\\n';\r\n  }\r\n  \r\n  xml += '</AquatronData>';\r\n  return { success: true, data: xml, format: 'xml' };\r\n};\r\n\r\n/**\r\n * Create a backup of current data\r\n * @param {Object} data - Data to backup\r\n * @param {string} filename - Backup filename\r\n * @returns {Object} Backup result\r\n */\r\nexport const createDataBackup = (data, filename = `aquatron_backup_${new Date().toISOString().split('T')[0]}.xlsx`) => {\r\n  try {\r\n    const backupData = {\r\n      deviceSettings: data.deviceSettings || {},\r\n      stpData: data.stpData || [],\r\n      voutTable: data.voutTable || [],\r\n      backupInfo: {\r\n        timestamp: new Date().toISOString(),\r\n        version: '1.0',\r\n        description: 'Automatic backup of Aquatron data'\r\n      }\r\n    };\r\n    \r\n    const result = exportComprehensiveData(\r\n      backupData.deviceSettings, \r\n      backupData.stpData, \r\n      filename,\r\n      { isBackup: true, timestamp: backupData.backupInfo.timestamp }\r\n    );\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    console.error('Backup creation error:', error);\r\n    return { success: false, message: 'Failed to create backup', error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Restore data from backup\r\n * @param {File} backupFile - Backup file to restore from\r\n * @returns {Object} Restore result\r\n */\r\nexport const restoreFromBackup = async (backupFile) => {\r\n  try {\r\n    const result = await importComprehensiveData(backupFile, {\r\n      validateData: true,\r\n      allowUnknownParameters: true,\r\n      isRestore: true\r\n    });\r\n    \r\n    if (result.success) {\r\n      // Validate backup integrity\r\n      if (!result.backupInfo) {\r\n        result.warnings.push('Backup file may not be a valid backup (missing backup info)');\r\n      }\r\n      \r\n      return result;\r\n    } else {\r\n      return result;\r\n    }\r\n  } catch (error) {\r\n    console.error('Restore error:', error);\r\n    return { success: false, message: 'Failed to restore from backup', error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Compare two datasets and highlight differences\r\n * @param {Object} originalData - Original data\r\n * @param {Object} newData - New data to compare\r\n * @returns {Object} Comparison result\r\n */\r\nexport const compareDataSets = (originalData, newData) => {\r\n  const differences = {\r\n    deviceSettings: {},\r\n    stpData: [],\r\n    voutTable: [],\r\n    summary: {\r\n      totalChanges: 0,\r\n      deviceSettingsChanges: 0,\r\n      stpDataChanges: 0,\r\n      voutTableChanges: 0\r\n    }\r\n  };\r\n  \r\n  try {\r\n    // Compare device settings\r\n    if (originalData.deviceSettings && newData.deviceSettings) {\r\n      Object.keys(originalData.deviceSettings).forEach(key => {\r\n        if (key !== 'vout_table' && originalData.deviceSettings[key] !== newData.deviceSettings[key]) {\r\n          differences.deviceSettings[key] = {\r\n            original: originalData.deviceSettings[key],\r\n            new: newData.deviceSettings[key]\r\n          };\r\n          differences.summary.deviceSettingsChanges++;\r\n          differences.summary.totalChanges++;\r\n        }\r\n      });\r\n    }\r\n    \r\n    // Compare STP data\r\n    if (originalData.stpData && newData.stpData) {\r\n      const originalMap = new Map(originalData.stpData.map(item => [item.symbol, item]));\r\n      const newMap = new Map(newData.stpData.map(item => [item.symbol, item]));\r\n      \r\n      // Find added, removed, and modified items\r\n      newData.stpData.forEach(newItem => {\r\n        const originalItem = originalMap.get(newItem.symbol);\r\n        if (!originalItem) {\r\n          differences.stpData.push({ type: 'added', item: newItem });\r\n          differences.summary.stpDataChanges++;\r\n          differences.summary.totalChanges++;\r\n        } else if (JSON.stringify(originalItem) !== JSON.stringify(newItem)) {\r\n          differences.stpData.push({ \r\n            type: 'modified', \r\n            symbol: newItem.symbol,\r\n            original: originalItem,\r\n            new: newItem \r\n          });\r\n          differences.summary.stpDataChanges++;\r\n          differences.summary.totalChanges++;\r\n        }\r\n      });\r\n      \r\n      originalData.stpData.forEach(originalItem => {\r\n        if (!newMap.has(originalItem.symbol)) {\r\n          differences.stpData.push({ type: 'removed', item: originalItem });\r\n          differences.summary.stpDataChanges++;\r\n          differences.summary.totalChanges++;\r\n        }\r\n      });\r\n    }\r\n    \r\n    return { success: true, differences };\r\n  } catch (error) {\r\n    console.error('Data comparison error:', error);\r\n    return { success: false, error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Export data summary report\r\n * @param {Object} data - Data to summarize\r\n * @param {string} filename - Output filename\r\n * @returns {Object} Export result\r\n */\r\nexport const exportDataSummary = (data, filename = 'aquatron_summary.xlsx') => {\r\n  try {\r\n    const wb = XLSX.utils.book_new();\r\n    \r\n    // Summary sheet\r\n    const summaryData = [\r\n      { Metric: 'Total Device Settings', Value: Object.keys(data.deviceSettings || {}).filter(k => k !== 'vout_table').length },\r\n      { Metric: 'Total STP Parameters', Value: (data.stpData || []).length },\r\n      { Metric: 'Total Vout Table Entries', Value: (data.voutTable || []).length },\r\n      { Metric: 'Export Date', Value: new Date().toISOString() },\r\n      { Metric: 'Data Version', Value: '1.0' }\r\n    ];\r\n    \r\n    const summaryWs = XLSX.utils.json_to_sheet(summaryData);\r\n    XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');\r\n    \r\n    // Statistics sheet\r\n    if (data.stpData && data.stpData.length > 0) {\r\n      const statsData = [\r\n        { Statistic: 'Average Quantity', Value: data.stpData.reduce((sum, item) => sum + (item.quantity || 0), 0) / data.stpData.length },\r\n        { Statistic: 'Average Vout Base', Value: data.stpData.reduce((sum, item) => sum + (item.vout_base || 0), 0) / data.stpData.length },\r\n        { Statistic: 'Average Frequency', Value: data.stpData.reduce((sum, item) => sum + (item.freq || 0), 0) / data.stpData.length },\r\n        { Statistic: 'Min Quantity', Value: Math.min(...data.stpData.map(item => item.quantity || 0)) },\r\n        { Statistic: 'Max Quantity', Value: Math.max(...data.stpData.map(item => item.quantity || 0)) }\r\n      ];\r\n      \r\n      const statsWs = XLSX.utils.json_to_sheet(statsData);\r\n      XLSX.utils.book_append_sheet(wb, statsWs, 'Statistics');\r\n    }\r\n    \r\n    XLSX.writeFile(wb, filename);\r\n    return { success: true, message: 'Data summary exported successfully', filename };\r\n  } catch (error) {\r\n    console.error('Summary export error:', error);\r\n    return { success: false, message: 'Failed to export data summary', error: error.message };\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}